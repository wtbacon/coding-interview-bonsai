# Happy Number (TODO: solve again)

- Pattern: Fast & Slow Pointers

## Problem

Given an non-negative number `num`, return `True` if it is a happy number otherwise return `False`.
A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are happy.

## Notes

- Time: $O(log{N})$

  1. If the number $N$ is less than or equal to 1000, then we reach the cycle or 1 in at most 1001 iterations.
  2. If $N$ is larger than 1000, the next value $N_1$ is significantly smaller than N.
     The largest possible $N_1$ for an M-digit number is less than or equal to $81 * M$ (when all digits are 9).  
     At this point, $M = \lfloor log_{10}{N} \rfloor + 1$ means that $M$ is proportional to $log{N}$, then $N_1$ is proportional to $O(log_{10}{N})$.  
     Therefore, in the next iteration, we will have a number that is at most $O(log{N})$. From there, we can reach the cycle or 1 in at most 1001 iterations.

- Space: $O(1)$
- Approach: The fast & slow pointer approach is used to detect the cycle in the sequence of numbers generated by the sum of squares of digits.
